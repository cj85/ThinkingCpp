/*
常量引进是在早期的C + +版本中，当时标准C规范正在制订。那时，常量被看作是一个好
的思想而被包含在C中。但是，C中的c o n s t意思是“一个不能被改变的普通变量”，在C中，它
总是占用存储而且它的名字是全局符。C编译器不能把c o n s t看成一个编译期间的常量。在C中，
如果写：
const bufsize=100；
char buf[bufsize]；
尽管看起来好像做了一件合理的事，但这将得到一个错误结果。因为b u f s i z e占用存储的某个地
方，所以C编译器不知道它在编译时的值。在C语言中可以选择这样书写：
const bufsize；
这样写在C + +中是不对的，而C编译器则把它作为一个声明，这个声明指明在别的地方有存储
分配。因为C默认c o n s t是外部连接的，C + +默认c o n s t是内部连接的，这样，如果在C + +中想完
成与C中同样的事情，必须用e x t e r n把连接改成外部连接：
extern const bufsize;//declaration only
这种方法也可用在C语言中。
在C语言中使用限定符c o n s t不是很有用，即使是在常数表达式里（必须在编译期间被求出）
想使用一个已命名的值，使用c o n s t也不是很有用的。C迫使程序员在预处理器里使用# d e f i n e。
*/